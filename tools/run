#!/usr/bin/env sh

set -eu

# Start timer.
start=$(date '+%s.%N')

log() { printf "[%s] %s\n" "$(date '+%H:%M:%S')" "$@"; }

took() {
    now=$(date '+%s.%N') # Unix Epoch and nanoseconds.
    res=$(printf "%f %f - p" "$now" "$start" | dc) # [FP]orth.
    log "$(printf "Done.  Action took %.2fs to complete.\n" "$res")"
}

check() {
    hint() {
        case "$1" in
            air) printf "Install it with 'go install github.com/cosmtrek/air@latest'.\n" ;;
            curl) printf "Install 'curl' with your package manager.\n" ;;
            go) printf "Install 'go' with your package manager.\n" ;;
            git) printf "Install 'git' with your package manager.\n" ;;
            sassc) printf "Install 'sassc' with your package manager.\n" ;;
            unzip) printf "Install 'unzip' with your package manager.\n" ;;
            vips) printf "Install 'vips' with your package manager.\n" ;;
        esac
    }

    for arg in "$@"; do
        if ! command -v "$arg" >/dev/null; then
            printf "Error: Missing '%s' dependency.\n" "$arg"
            hint "$arg"
            return 1
        fi
    done
}

getFonts() {
    log "Downloading fonts."

    # Extract the latest release.
    url="https://api.github.com/repos/rsms/inter/releases/latest"
    src=$(curl -s "$url" | sed -n 's|.*browser_download_url.*"\(http.*\)"|\1|p')

    # Extract tag version from the following URL:
    # https://github.com/rsms/inter/releases/download/v3.19/Inter-3.19.zip
    version=$(printf "%s" "$src" | sed -n 's|.*\/\(v.*\)\/.*|\1|p')

    archive="data/inter-${version}.zip"
    distDir="web/static/fonts"

    extract() {
        # Extract specific variants that we use.
        fonts="Regular Bold Italic BoldItalic"
        for font in $fonts; do
            unzip -j -d "$distDir" "$archive" "Inter Web/Inter-${font}.*"
        done
    }

    # Check if the latest version isn't downloaded.
    if [ ! -e "$archive" ]; then
        log "Downloading Inter $version archive."

        # Remove old fonts.
        rm -rf "$distDir"

        # Download the archive with their respective version number.
        curl -L "$src" -o "$archive"

        extract
    else
        # Skip if directory exists, otherwise extract fonts.
        if [ -e "$distDir" ]; then
            log "Fonts are up to date."
        else
            extract
        fi
    fi
}

watch() {
    case "$1" in
        go)
            log "Watching Go files."
            air -c tools/air_go.toml
            ;;
        [tj]s)
            log "Watching TypeScript files."
            env DEBUG="true" air -c tools/air_ts.toml
            ;;
        s[as]ss|css)
            log "Watching Sass files."
            air -c tools/air_sass.toml
            ;;
    esac
}

setupSass() {
    log "Setting up Sass."

    # Sassc fails to create the compiled file if target directory doesn't exist,
    # so we have to create it manually.
    mkdir -p web/static/css

    # Compile initial CSS file.
    compileSass
}

compileSass() {
    log "Compiling Sass files."
    sassc web/scss/main.scss web/static/css/main.css
}

drop() {
    log "Dropping database tables."

    env DB_DROP="1" \
        DB_COLOR="true" \
        DB_DEBUG="${2:-silent}" \
        DB_RANDOM_DATA="${3:-false}" \
        air -c tools/air_go.toml
}

setupTS() {
    log "Setting up TypeScript environment."
    go build -v -o bin/userstyles-ts cmd/userstyles-ts/main.go

    # Compile initial JS file.
    compileTSDev
}

compileTSDev() {
    log "Compiling TS files for development."
    env DEBUG="true" ./bin/userstyles-ts
}

compileTSProd() {
    log "Compiling TS files for production."
    ./bin/userstyles-ts
}

setupGo() {
    log "Setting up Go environment."
    compileGoDev
}

compileGoDev() {
    log "Compiling executable."
    go build -v -o bin/userstyles-world cmd/userstyles-world/main.go
}

compileGoProd() {
    log "Compiling static executable."

    f="-s -w -extldflags '-fno-PIC -static'"
    f="$f -X userstyles.world/modules/config.GitCommit=$(git rev-list -1 HEAD)"
    f="$f -X userstyles.world/modules/config.GitVersion=$(git describe --tags)"

    go build -v \
        -o bin/userstyles-world \
        -ldflags "$f" -buildmode pie \
        -tags 'osusergo netgo static_build' \
        cmd/userstyles-world/main.go
}

buildCmd() {
    err() {
        printf "Error: Invalid argument '%s'.  Try using one of: " "$1"
        printf "go, ts, sass, dev, or prod.\n"
        return 1
    }

    compile() {
        log "Building USw for $1 environment."
        case "$1" in
            dev)  compileSass; compileTSDev;  compileGoDev  ;;
            prod) compileSass; compileTSProd; compileGoProd ;;
        esac
    }

    if [ $# -ge 1 ]; then
        case "$1" in
            go)          compileGoDev ;;
            [tj]s)       compileTSDev ;; # Match on ts or js.
            s[ac]ss|css) compileSass  ;; # Match on sass, scss, or css.
            dev)         compile dev  ;;
            prod)        compile prod ;;
            *)           err "$1"     ;;
        esac
    else
        printf "Error: No argument found.  Try using dev or prod.\n"
        return 1
    fi
}

configCmd() {
    if [ $# -ge 1 ]; then
        if  [ -e "tools/${1}" ]; then
            printf "Loading environment variables from '%s' file.\n" "$1"
            set -a
            # shellcheck disable=SC1090
            . "tools/${1}"
            set +a
        else
            printf "Failed to load environment variables from '%s' file.\n" "$1"
            return 1
        fi
    else
        printf "Error: No argument found.  Try passing a valid env file.\n"
        return 1
    fi
}

setupCmd() {
    log "Setting up development environment."
    mkdir -p data
    getFonts
    setupSass
    setupTS
    setupGo
}

startCmd() {
    log "Starting USw."
    check vips
    ./bin/userstyles-world
}

watchCmd() {
    check air vips

    err() {
        printf "Error: Invalid argument '%s'.  Try using one of: " "$1"
        printf "go, ts, or sass.\n"
        return 1
    }

    if [ $# -ge 1 ]; then
        case "$1" in
            go)          watch go   ;;
            [tj]s)       watch ts   ;; # Match on ts or js.
            s[ac]ss|css) watch sass ;; # Match on sass, scss, or css.
            *)           err "$1"   ;;
        esac
    else
        # TODO: Show usage for this command.
        printf "Error: No argument found.  Try using go, ts, or sass.\n"
        return 1
    fi
}

fallbackCmd() {
    printf "Error: Unknown subcommand '%s'.\n" "$1"
    # TODO: Show usage/help command.
    return 1
}

main() {
    if [ $# -eq 0 ]; then
        printf "Error: No arguments.\n"
        # TODO: Show usage/help command.
        return 1
    fi

    # Check if build dependencies are installed.
    check git go curl unzip sassc

    # Go to project's root directory.
    cd "$(git rev-parse --show-toplevel)"

    # Command/argument parser.
    while [ $# -gt 0 ]; do
        case "$1" in
            build)
                shift; buildCmd "$@"; took; shift ;;
            dev) # TODO: Move to 'watch' under 'all'.
                shift; compileGoDev "$@" ;;
            drop) # TODO: Remove? I suppose we could handle it in Go code.
                shift; drop "$@" ;;
            config)
                shift; configCmd "$@"; shift ;;
            setup)
                shift; setupCmd "$@"; took ;;
            start)
                shift; startCmd "$@" ;;
            watch)
                shift; watchCmd "$@"; return 0 ;;
            *)
                fallbackCmd "$@" ;;
        esac
    done
}

main "$@"
