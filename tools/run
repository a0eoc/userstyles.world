#!/usr/bin/env sh

set -eu

# Start timer.
start=$(date '+%s.%N')

log() { printf "[%s] %s\n" "$(date '+%H:%M:%S')" "$@"; }

took() {
    now=$(date '+%s.%N') # Unix Epoch and nanoseconds.
    res=$(printf "%f %f - p" "$now" "$start" | dc) # [FP]orth.
    log "$(printf "Done.  Action took %.2fs to complete.\n" "$res")"
}

check() {
    hint() {
        case "$1" in
            air) printf "Install it with 'go install github.com/cosmtrek/air@latest'.\n" ;;
            curl) printf "Install 'curl' with your package manager.\n" ;;
            go) printf "Install 'go' with your package manager.\n" ;;
            git) printf "Install 'git' with your package manager.\n" ;;
            sassc) printf "Install 'sassc' with your package manager.\n" ;;
            unzip) printf "Install 'unzip' with your package manager.\n" ;;
            vips) printf "Install 'vips' with your package manager.\n" ;;
        esac
    }

    for arg in "$@"; do
        if ! command -v "$arg" >/dev/null; then
            printf "Error: Missing '%s' dependency.\n" "$arg"
            hint "$arg"
            return 1
        fi
    done
}

getFonts() {
    log "Downloading fonts."

    # Extract the latest release.
    url="https://api.github.com/repos/rsms/inter/releases/latest"
    src=$(curl -s "$url" | sed -n 's|.*browser_download_url.*"\(http.*\)"|\1|p')

    # Extract tag version from the following URL:
    # https://github.com/rsms/inter/releases/download/v3.19/Inter-3.19.zip
    version=$(printf "%s" "$src" | sed -n 's|.*\/\(v.*\)\/.*|\1|p')

    archive="${DATA_DIR:=data}/inter-${version}.zip"
    distDir="web/static/fonts"

    extract() {
        # Extract specific variants that we use.
        fonts="Regular Bold Italic BoldItalic"
        for font in $fonts; do
            unzip -j -d "$distDir" "$archive" "Inter Web/Inter-${font}.*"
        done
    }

    # Check if the latest version isn't downloaded.
    if [ ! -e "$archive" ]; then
        log "Downloading Inter $version archive."

        # Remove old fonts.
        rm -rf "$distDir"

        # Download the archive with their respective version number.
        curl -L "$src" -o "$archive"

        extract
    else
        # Skip if directory exists, otherwise extract fonts.
        if [ -e "$distDir" ]; then
            log "Fonts are up to date."
        else
            extract
        fi
    fi
}

build() {
    case "$1" in
        go-dev)
            : "Setting BIN to ${BIN:=bin/userstyles-dev}."
            log "Compiling development executable to ${BIN}."
            go build -v -o "$BIN" cmd/userstyles-world/main.go
            ;;
        go-prod)
            : "Setting BIN to ${BIN:=bin/userstyles-prod}."
            log "Compiling production executable to ${BIN}."

            c="$(git rev-list -1 HEAD)"
            v="$(git describe --tags)"
            f="-s -w -extldflags '-fno-PIC -static'"
            f="$f -X userstyles.world/modules/config.GitCommit=${c}"
            f="$f -X userstyles.world/modules/config.GitVersion=${v}"

            go build -v \
                -o "$BIN" \
                -ldflags "$f" \
                -buildmode pie \
                -tags 'osusergo netgo static_build' \
                cmd/userstyles-world/main.go
            ;;
        ts-dev)
            log "Compiling TypeScript for development environment."
            env DEBUG="true" ./bin/userstyles-ts
            ;;
        ts-prod)
            log "Compiling TypeScript for production environment."
            ./bin/userstyles-ts
            ;;
        sass)
            log "Compiling Sass files."
            sassc web/scss/main.scss web/static/css/main.css
            ;;
        dev)
            log "Building USw for $1 environment."
            build sass; build ts-dev; build go-dev
            ;;
        prod)
            log "Building USw for $1 environment."
            build sass; build ts-prod; build go-prod
            ;;
    esac
}

setup() {
    case "$1" in
        go)
            log "Setting up Go environment."

            # Build initial executable.
            build go-dev
            ;;
        ts)
            log "Setting up TypeScript environment."

            # Build esbuild executable.
            go build -v -o bin/userstyles-ts cmd/userstyles-ts/main.go

            # Build initial JS file.
            build ts-dev
            ;;
        sass)
            log "Setting up Sass environment."

            # Sassc fails to create the compiled file if target directory
            # doesn't exist, so we have to create it manually.
            mkdir -p web/static/css

            # Build initial CSS file.
            build sass
            ;;
    esac
}

watch() {
    case "$1" in
        go)
            log "Watching Go files."
            air -c tools/air_go.toml
            ;;
        [tj]s)
            log "Watching TypeScript files."
            env DEBUG="true" air -c tools/air_ts.toml
            ;;
        s[as]ss|css)
            log "Watching Sass files."
            air -c tools/air_sass.toml
            ;;
        all|dev)
            # Execute jobs in subshells, so that we can run all of them
            # simultaneously.  I'm not sure if there's a better way to implement
            # this functionality, but this is the best attempt I could come up
            # with that doesn't have any dealbreaking downsides to it.  Delay is
            # there only to separate log messages.
            (watch sass) &
            (sleep 0.4 && watch ts) &
            (sleep 0.8 && watch go) &

            # Wait for subshells to terminate before exiting the process,
            # otherwise you'd have to manually kill processes.
            wait
            ;;
    esac
}

drop() {
    log "Dropping database tables."

    env DB_DROP="1" \
        DB_COLOR="true" \
        DB_DEBUG="${2:-silent}" \
        DB_RANDOM_DATA="${3:-false}" \
        air -c tools/air_go.toml
}

buildCmd() {
    err() {
        printf "Error: Invalid argument '%s'.  Try using one of: " "$1"
        printf "go, ts, sass, dev, or prod.\n"
        return 1
    }

    if [ $# -ge 1 ]; then
        case "$1" in
            go)          build go-dev ;;
            [tj]s)       build ts-dev ;; # Match on ts or js.
            s[ac]ss|css) build sass   ;; # Match on sass, scss, or css.
            dev)         build dev    ;;
            prod)        build prod   ;;
            *)           err "$1"     ;;
        esac
    else
        printf "Error: No argument found.  Try using dev or prod.\n"
        return 1
    fi
}

configCmd() {
    if [ $# -ge 1 ]; then
        if  [ -e "$1" ]; then
            log "Loading variables from '$1' file."
            set -a
            # shellcheck disable=SC1090
            . "$1"
            set +a
        else
            log "Error: Failed to load '$1' file.  Is the path correct?"
            return 1
        fi
    else
        log "Error: No argument found.  Try passing a valid file."
        return 1
    fi
}

setupCmd() {
    : "Setting DATA_DIR to ${DATA_DIR:=data}"
    log "Setting up development environment."

    mkdir -p "$DATA_DIR"
    getFonts
    setup sass
    setup ts
    setup go

    # Perform database migration and exit.
    DB_DROP=1 DB_MIGRATE=1 startCmd
}

startCmd() {
    : "Setting BIN to ${BIN:=bin/userstyles-dev}."
    log "Starting USw from ${BIN}."
    check vips
    "./${BIN}"
}

watchCmd() {
    check air vips

    err() {
        printf "Error: Invalid argument '%s'.  Try using one of: " "$1"
        printf "go, ts, or sass.\n"
        return 1
    }

    if [ $# -ge 1 ]; then
        case "$1" in
            go)          watch go   ;;
            [tj]s)       watch ts   ;; # Match on ts or js.
            s[ac]ss|css) watch sass ;; # Match on sass, scss, or css.
            all|dev)     watch all  ;;
            *)           err "$1"   ;;
        esac
    else
        # TODO: Show usage for this command.
        printf "Error: No argument found.  Try using go, ts, or sass.\n"
        return 1
    fi
}

fallbackCmd() {
    printf "Error: Unknown subcommand '%s'.\n" "$1"
    # TODO: Show usage/help command.
    return 1
}

main() {
    if [ $# -eq 0 ]; then
        printf "Error: No arguments.\n"
        # TODO: Show usage/help command.
        return 1
    fi

    # Check if build dependencies are installed.
    check git go curl unzip sassc

    # Go to project's root directory.
    cd "$(git rev-parse --show-toplevel)"

    # Command/argument parser.
    while [ $# -gt 0 ]; do
        case "$1" in
            build)
                shift; buildCmd "$@"; took; shift ;;
            drop) # TODO: Remove? I suppose we could handle it in Go code.
                shift; drop "$@" ;;
            config)
                shift; configCmd "$@"; shift ;;
            setup)
                shift; setupCmd "$@"; took ;;
            start)
                shift; startCmd "$@" ;;
            watch)
                shift; watchCmd "$@"; return 0 ;;
            *)
                fallbackCmd "$@" ;;
        esac
    done
}

main "$@"
