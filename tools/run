#!/usr/bin/env sh

set -eu

# Start timer.
start=$(date '+%s.%N')

log() { printf "%s %s\n" "$(date '+%Y-%m-%d %H:%M:%S')" "$@"; }

took() {
    now=$(date '+%s.%N') # Unix Epoch and nanoseconds.
    res=$(printf "%f %f - p" "$now" "$start" | dc) # [FP]orth.
    log "$(printf "Done.  Action took %.2fs to complete.\n" "$res")"
}

check() {
    hint() {
        case "$1" in
            air) printf "Install it with 'go install github.com/cosmtrek/air@latest'.\n" ;;
            curl) printf "Install 'curl' with your package manager.\n" ;;
            go) printf "Install 'go' with your package manager.\n" ;;
            git) printf "Install 'git' with your package manager.\n" ;;
            sassc) printf "Install 'sassc' with your package manager.\n" ;;
            unzip) printf "Install 'unzip' with your package manager.\n" ;;
        esac
    }

    for arg in "$@"; do
        if ! command -v "$arg" >/dev/null; then
            printf "Error: Missing '%s' dependency.\n" "$arg"
            hint "$arg"
            return 1
        fi
    done
}

getFonts() {
    log "Downloading fonts."
    check curl unzip

    # Extract the latest release.
    url="https://api.github.com/repos/rsms/inter/releases/latest"
    src=$(curl -s "$url" | sed -n 's|.*browser_download_url.*"\(http.*\)"|\1|p')

    # Extract tag version from the following URL:
    # https://github.com/rsms/inter/releases/download/v3.19/Inter-3.19.zip
    version=$(printf "%s" "$src" | sed -n 's|.*\/\(v.*\)\/.*|\1|p')

    extract() {
        # Extract specific variants that we use.
        fonts="Regular Bold Italic BoldItalic"
        for font in $fonts; do
            unzip -j -d web/static/fonts \
                "data/inter-${1}.zip" "Inter Web/Inter-${font}.*"
        done
    }

    # Check if the latest version is installed.
    if [ ! -e "data/inter-${version}.zip" ]; then
        # If fonts directory exists, remove it.
        if [ -e web/static/fonts ]; then
            log "Removing old fonts."
            rm -f data/inter-*.zip
            rm -rf web/static/fonts
        fi

        log "Downloading Inter $version..."

        # Download the archive with their respective version number.
        curl -L "$src" -o "data/inter-$version.zip"

        extract "$version"
    else
        # If fonts directory doesn't exist, extract fonts.
        if [ ! -e web/static/fonts ]; then
            log "Extracting fonts..."
            extract "$version"
        else
            log "Fonts are up to date."
        fi
    fi
}

setupSass() {
    log "Setting up Sass."

    # Sassc fails to create the compiled file if target directory doesn't exist,
    # so we have to create it manually.
    mkdir -p web/static/css

    # Compile initial CSS file.
    compileSass
}

watchSass() {
    log "Watching Sass files."
    air -c tools/air_sass.toml
}

compileSass() {
    log "Compiling Sass files."
    sassc web/scss/main.scss web/static/css/main.css
}

drop() {
    log "Dropping database tables."

    env DB_DROP="1" \
        DB_COLOR="true" \
        DB_DEBUG="${2:-silent}" \
        DB_RANDOM_DATA="${3:-false}" \
        air -c tools/air.toml
}

watchGo() {
    log "Watching Go files."
    air -c tools/air.toml
}

compileGoDev() {
    log "Compiling executable."
    go build -v -o bin/userstyles-world cmd/userstyles-world/main.go
}

compileGoProd() {
    log "Compiling static executable."

    f="-s -w -extldflags '-fno-PIC -static'"
    f="$f -X userstyles.world/modules/config.GitCommit=$(git rev-list -1 HEAD)"
    f="$f -X userstyles.world/modules/config.GitVersion=$(git describe --tags)"

    go build -v \
        -o bin/userstyles-world \
        -ldflags "$f" -buildmode pie \
        -tags 'osusergo netgo static_build' \
        cmd/userstyles-world/main.go
}

setupTS() {
    log "Compiling TypeScript executable."
    go build -v -o bin/userstyles-ts cmd/userstyles-ts/main.go
}

ts() {
    log "Compiling TypeScript files."

    env DEBUG="${2:-false}" \
        WATCH="${3:-false}" \
        ./bin/userstyles-ts
}

buildCmd() {
    if [ $# -ge 1 ]; then
        case "$1" in
            dev)
                log "Build development USw executable."
                ts; compileSass; compileGoDev
                ;;
            prod)
                log "Build production USw executable."
                ts; compileSass; compileGoProd
                ;;
            *)
                printf "Error: Invalid argument '%s'.  " "$1"
                printf "Try using dev or prod."
                return 1
                ;;
        esac
    else
        printf "Error: No argument found.  Try using dev or prod.\n"
        return 1
    fi
}

configCmd() {
    if [ $# -ge 1 ]; then
        if  [ -e "tools/${1}" ]; then
            printf "Loading environment variables from '%s' file.\n" "$1"
            set -a
            # shellcheck disable=SC1090
            . "tools/${1}"
            set +a
        else
            printf "Failed to load environment variables from '%s' file.\n" "$1"
            return 1
        fi
    else
        printf "Error: No argument found.  Try passing a valid env file.\n"
        return 1
    fi
}

setupCmd() {
    log "Setting up development environment."
    getFonts
    setupTS
    setupSass
    compileGoDev
}

startCmd() {
    log "Starting USw."
    ./bin/userstyles-world
}

watchCmd() {
    if [ $# -eq 1 ]; then
        case "$1" in
            go) watchGo ;;
            [jt]s) ts '' 'true' 'true' ;;
            s[ac]ss|css) watchSass ;; # Match on sass, scss, or css.
            *)
                printf "Error: Invalid argument '%s'.  " "$1"
                printf "Try using go, ts, or sass.\n"
                return 1
                ;;
        esac
    else
        printf "Error: No argument found.  Try using go, ts, or sass.\n"
        return 1
    fi
}

fallbackCmd() {
    printf "Error: Unknown subcommand '%s'.\n" "$1"
    # TODO: Show usage/help command.
    return 1
}

init() {
    if [ $# -eq 0 ]; then
        printf "Error: No arguments.\n"
        # TODO: Show usage/help command.
        return 1
    fi

    # Seems unnecessary, but you never know.
    check git go air

    # Go to project's root directory.
    cd "$(git rev-parse --show-toplevel)"
}

init "$@"

while [ $# -gt 0 ]; do
    case "$1" in
        build)
            shift; buildCmd "$@"; took; shift ;;
        dev) # TODO: Move to 'watch' under 'all'.
            shift; compileGoDev "$@" ;;
        drop) # TODO: Remove? I suppose we could handle it in Go code.
            shift; drop "$@" ;;
        config)
            shift; configCmd "$@"; shift ;;
        setup)
            shift; setupCmd "$@"; took ;;
        start)
            shift; startCmd "$@" ;;
        watch)
            shift; watchCmd "$@"; shift ;;
        *)
            fallbackCmd "$@" ;;
    esac
done
